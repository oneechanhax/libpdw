
# libpdraw
cmake_minimum_required (VERSION 3.0.2)
project (libpdraw VERSION 0.0.0 LANGUAGES CXX)

find_package(ImageMagick REQUIRED COMPONENTS convert identify )
#if (NOT ImageMagick_idenity_FOUND)
    #message(FATAL "Please install imagemagick identify")

function(CommandConvertImageToRgba file_in)
  cmake_path(GET file_in FILENAME filename)
  cmake_path(GET file_in PARENT_PATH filepath)
  add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${filename}.rgba
                     WORKING_DIRECTORY ${filepath}
                     COMMAND ${ImageMagick_convert_EXECUTABLE}
                     ARGS ${filename} -depth 8 -format rgba ${CMAKE_CURRENT_BINARY_DIR}/${filename}.rgba
                     DEPENDS ${file_in}
                     POST_BUILD)
  set(FUNC_RET ${CMAKE_CURRENT_BINARY_DIR}/${filename}.rgba PARENT_SCOPE)
endfunction()

function(CommandConvertToObjcopy file_in)
  cmake_path(GET file_in FILENAME filename)
  cmake_path(GET file_in PARENT_PATH filepath)
  add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${filename}.o
                     WORKING_DIRECTORY ${filepath}
                     COMMAND ${CMAKE_OBJCOPY}
                     ARGS --input binary --output elf64-x86-64 --binary-architecture i386 ${filename} ${CMAKE_CURRENT_BINARY_DIR}/${filename}.o
                     DEPENDS ${file_in}
                     POST_BUILD)
  set(FUNC_RET ${CMAKE_CURRENT_BINARY_DIR}/${filename}.o PARENT_SCOPE)
endfunction()

function(CommandConvertImageToObject file_in)
  CommandConvertImageToRgba("${file_in}")
  CommandConvertToObjcopy(${FUNC_RET})
  set(FUNC_RET ${FUNC_RET} PARENT_SCOPE)
endfunction()


function(EmbedResources)
  set(EMBED_HEADER_DIR "${CMAKE_CURRENT_BINARY_DIR}/")
  set(EMBED_HEADER_DIR "${EMBED_HEADER_DIR}" PARENT_SCOPE)
  file(WRITE "${EMBED_HEADER_DIR}/embed_resources.hpp" "
/* AUTOGENERATED CMAKE EMBEDED FILE HEADER!!! DO NOT EDIT THIS FILE!!!
   ALL CHANGES WILL BE WIPED!!! */
#include <cstddef>
#include <iterator>
class EmbededResource {
public:
    constexpr EmbededResource(const std::byte* _begin, const std::byte* _end)
        : begin(_begin), end(_end), size(std::distance(_begin, _end)) {
        //static_assert(this->begin != nullptr && this->end != nullptr);
    }
    const std::byte* const begin;
    const std::byte* const end;
    std::size_t size;
};
class EmbededImage {
public:
    constexpr EmbededImage(std::size_t _width, std::size_t _height, EmbededResource _data)\
        : width(_width), height(_height), data(_data) {
        //static_assert(this->width != 0 && this->height);
    }
    const std::size_t width;
    const std::size_t height;
    const EmbededResource data;
};
")

  set(EMBED_OBJ_RET "")
  foreach(file_path ${ARGV})
    cmake_path(GET file_path EXTENSION LAST_ONLY file_ext)
    set(type "embed")
    if (file_ext STREQUAL ".jpg")
      set(type "image")
    endif()
    if (file_ext STREQUAL ".png")
      set(type "image")
    endif()

    if (type STREQUAL "image")
      CommandConvertImageToObject(${file_path})
    elseif (type STREQUAL "embed")
      CommandConvertToObjcopy(${file_path})
    endif()
    list(APPEND EMBED_OBJ_RET "${FUNC_RET}")

    cmake_path(GET FUNC_RET STEM LAST_ONLY obj_filestem)
    string(REPLACE "." "_" obj_cleaned_name "${obj_filestem}")
    file(APPEND "${EMBED_HEADER_DIR}/embed_resources.hpp" "extern const std::byte _binary_${obj_cleaned_name}_start; extern const std::byte _binary_${obj_cleaned_name}_end; \n")

    if (type STREQUAL "image")
        cmake_path(GET file_path PARENT_PATH file_parent)
        cmake_path(GET file_path FILENAME file_name)
        exec_program("${ImageMagick_identify_EXECUTABLE}" "${file_parent}"
            ARGS -format "%[fx:w]" "${file_name}"
            OUTPUT_VARIABLE image_width)
        exec_program("${ImageMagick_identify_EXECUTABLE}" "${file_parent}"
            ARGS -format "%[fx:h]" "${file_name}"
            OUTPUT_VARIABLE image_height)
        file(APPEND "${EMBED_HEADER_DIR}/embed_resources.hpp" "inline EmbededImage embeded_${obj_cleaned_name}(${image_width}, ${image_height}, EmbededResource(&_binary_${obj_cleaned_name}_start, &_binary_${obj_cleaned_name}_end)); \n")

    elseif (type STREQUAL "embed")
      file(APPEND "${EMBED_HEADER_DIR}/embed_resources.hpp" "inline EmbededResource embeded_${obj_cleaned_name}(&_binary_${obj_cleaned_name}_start, &_binary_${obj_cleaned_name}_end); \n")
    endif()

  endforeach()
  set(EMBED_OBJ_RET "${EMBED_OBJ_RET}" PARENT_SCOPE)
endfunction()

EmbedResources("${CMAKE_CURRENT_SOURCE_DIR}/res/opensans.ttf" "${CMAKE_CURRENT_SOURCE_DIR}/res/logo.png" "${CMAKE_CURRENT_SOURCE_DIR}/res/flame.png" "${CMAKE_CURRENT_SOURCE_DIR}/res/heart.png" "${CMAKE_CURRENT_SOURCE_DIR}/res/raindrop.png" "${CMAKE_CURRENT_SOURCE_DIR}/res/raindrop2.png" "${CMAKE_CURRENT_SOURCE_DIR}/res/snowflake.png")

file(GLOB_RECURSE sources "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")
add_library(libpdraw STATIC ${EMBED_OBJ_RET} ${sources})
target_include_directories(libpdraw PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/example-src/lib/" "${CMAKE_CURRENT_SOURCE_DIR}/src/" "${CMAKE_CURRENT_SOURCE_DIR}/include/libpdraw" "${EMBED_HEADER_DIR}")

# Example using xoverlay
set(OpenGL_GL_PREFERENCE "GLVND")
find_package(PNG) # We need to link all this again since we prebuilt them staticly
find_package(GLEW)
find_package(OpenGL)
find_package(X11)
find_package(Freetype)
if(PNG_FOUND AND GLEW_FOUND AND OPENGL_FOUND AND X11_FOUND AND FREETYPE_FOUND)
  project (example)

  file(GLOB_RECURSE sources "${CMAKE_CURRENT_SOURCE_DIR}/example-src/*.c*")
  add_executable(example ${sources})

  target_include_directories(example PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/example-src/lib/" "${CMAKE_CURRENT_SOURCE_DIR}/include/")
  target_link_libraries(example libpdraw
                        "${CMAKE_CURRENT_SOURCE_DIR}/example-src/lib/libxoverlay.a"
                        glez
                         ${PNG_LIBRARIES} GL GLU GLEW ${FREETYPE_LIBRARIES} ${X11_X11_LIB} ${X11_Xext_LIB} ${X11_Xfixes_LIB})
endif()
